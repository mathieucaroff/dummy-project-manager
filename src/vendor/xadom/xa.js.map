{"version":3,"sources":["elem/wrapperFunc.ts","elem/wrapperProp.ts","util/xaUtil.ts","xa.ts"],"names":[],"mappings":"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","file":"xa.js","sourceRoot":"..\\src","sourcesContent":["import { Xa, XaElement } from '../xa'\n\nexport interface WrapperFunc<T> {\n   $: <R extends Element>(selector: string) => XaElement<R> | undefined\n   $$: <R extends Element>(selector: string) => XaElement<R>[]\n   append: <T extends Node | string>(child: T) => T\n   clone: (deep: boolean) => T\n   on: <K extends keyof ElementEventMap>(\n      type: K,\n      listener: (this: Element, ev: ElementEventMap[K]) => any,\n      option?: boolean | AddEventListenerOptions,\n   ) => { remove: () => void }\n}\n\nexport const wrapperFunc = <T extends Element>(\n   el: T,\n   xa: Xa,\n): WrapperFunc<T> => {\n   let wrapperFunc: WrapperFunc<T> = {\n      $: <R extends Element>(selector: string): XaElement<R> | undefined => {\n         let result = el.querySelector<R>(selector)\n         return result !== null ? xa.wrap(result) : undefined\n      },\n      $$: <R extends Element>(selector: string): XaElement<R>[] => {\n         return Array.from(el.querySelectorAll<R>(selector)).map(xa.wrap)\n      },\n      append: <T extends Node | string>(child: T): T => {\n         el.appendChild(xa.intoTextNode(child))\n         return child\n      },\n      clone: (deep: boolean): T => xa.wrap(el.cloneNode(deep) as T),\n      on: <K extends keyof ElementEventMap>(\n         type: K,\n         listener: (this: Element, ev: ElementEventMap[K]) => any,\n         option?: boolean | AddEventListenerOptions,\n      ) => {\n         el.addEventListener(type, listener, option)\n         let remove = () => {\n            el.removeEventListener(type, listener, option)\n         }\n         return { remove }\n      },\n   }\n   return wrapperFunc\n}\n","import { Xa, XaElement } from '../xa'\n\nexport type WrapperProp = {\n   count: number\n   first?: XaElement<Element>\n   last?: XaElement<Element>\n   firstNode?: Node\n   lastNode?: Node\n   nodes: Node[]\n}\n\nexport const wrapperProp = <T extends Element>(el: T, xa: Xa): WrapperProp => {\n   let xaProp = {\n      get count() {\n         return el.childElementCount\n      },\n      get first() {\n         let res = el.firstElementChild\n         return res !== null ? xa.wrap(res) : undefined\n      },\n      get firstNode() {\n         return el.firstChild || undefined\n      },\n      get last() {\n         let res = el.lastElementChild\n         return res !== null ? xa.wrap(res) : undefined\n      },\n      get lastNode() {\n         return el.lastChild || undefined\n      },\n      get nodes() {\n         return Array.from(el.childNodes)\n      },\n   }\n   return xaProp\n}\n","export const createXaUtil = (d: Document) => {\n   let create = <\n      K extends keyof (HTMLElementTagNameMap | SVGElementTagNameMap)\n   >(\n      name: K,\n      attribute: Record<string, string> = {},\n      children: Element[] = [],\n   ) => {\n      let elem = d.createElement<K>(name as K)\n\n      Object.entries(attribute).forEach(([name, value]) => {\n         if (elem[name] !== undefined) {\n            elem[name] = value\n         } else {\n            elem.setAttribute(name, value)\n         }\n      })\n\n      children.forEach((child) => {\n         elem.appendChild(child)\n      })\n\n      return elem\n   }\n\n   let intoTextNode = (child: Node | string) => {\n      let node: Node\n      if (typeof child === 'string') {\n         node = d.createTextNode(child)\n      } else {\n         node = child\n      }\n      return node\n   }\n\n   let xaUtil = {\n      create,\n      intoTextNode,\n   }\n\n   return xaUtil\n}\n\nexport type XaUtil = ReturnType<typeof createXaUtil>\n","import { WrapperFunc, wrapperFunc } from './elem/wrapperFunc'\nimport { WrapperProp, wrapperProp } from './elem/wrapperProp'\nimport { createXaUtil, XaUtil } from './util/xaUtil'\n\nexport interface XaProp {\n   document: Document\n}\n\nexport type XaElement<T extends Element> = T &\n   WrapperProp &\n   WrapperFunc<T> & {\n      _: T\n   }\n\nexport type Xa = XaUtil &\n   Document & {\n      wrap: <T extends Element>(el: T) => XaElement<T>\n   } & {\n      body: XaElement<HTMLElement>\n      head: XaElement<HTMLHeadElement>\n      html: XaElement<HTMLElement>\n   }\n\nexport const createXa = (prop: XaProp): Xa => {\n   let { document: d } = prop\n\n   let xaUtil = createXaUtil(d)\n\n   let wrap = <T extends Element>(el: T): XaElement<T> => {\n      if ('$' in el) {\n         return el as any\n      }\n\n      let elWrapperProp = wrapperProp(el, xa)\n      let elWrapperFunc = wrapperFunc(el, xa)\n\n      return Object.setPrototypeOf(\n         {\n            ...elWrapperFunc,\n            ...elWrapperProp,\n            _: el,\n         },\n         el,\n      )\n   }\n\n   let xa: Xa = Object.setPrototypeOf(\n      {\n         get body() {\n            return wrap(d.body)\n         },\n         get html() {\n            return wrap(d.documentElement)\n         },\n         get head() {\n            return wrap(d.head)\n         },\n         ...xaUtil,\n\n         // Wrapper\n         wrap,\n      },\n      document,\n   )\n\n   return xa\n}\n"]}